# PPeng Code
> Get into Leetcode~

## **problem 5: longestPalindromeSubstring**
> 动态规划， 此处没有用动态规划解决

* 当前解法: 中心扩展法，回文字符串两侧互为镜像可以从中心展开
    * 一共有$2n-1$个中心点，需要考虑字符串长度的奇偶性
    * 时间复杂度 $O\left(n^{2}\right)$ , 空间复杂度 $O\left(1\right)$

## **problem 53: Maxsubarray**
> 动态规划
* DP算法的主要解题步骤，通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法，DP使用于有重叠子问题和最优子结构性质的问题
    * 确定问题具有最优子结构性质
    * 构造最优值的递归关系表达式
    * 最优值的算法描述
    * 构造最优解
* 当前解法: 动态规划算法，定义一个最优解数组 $\mathrm{dp}[\mathrm{i}]$ 来记录截止到当前元素的最大子序列和
    * 确定问题具有最优子结构性质: 以下标$i$作为结尾的子序列最大和可以通过$i-1$的子序列最大和以及$array[i]$的值来判断;
    * 构造最优值的递归关系表达式: $\mathrm{dp}[i]=\max (\mathrm{dp}[\mathrm{i}-1]+ nums[i], nums[i])$, 并修改当前子序列的head的指向；
    * 最优值算法描述&&构造最优解: 根据数组前三项总结出以当前项为尾节点的子序列的最大序列和，同时需要记录子序列头结点的位置; 计算出dp数组所有的最大子序列和然后遍历一遍求出最优解，同时还可以返回子序列的position;

## **problem 62: UniquePaths**
> 动态规划
* 当前解法: 动态规划算法，定义一个最优解数组paths来记录到达当前坐标$(i,j)$的路径数目
    * 确定问题具有最优子结构性质: 在这个题目的场景中到达坐标$(i,j)$的路径数可以通过它上和左边的坐标点路径数来确定；
    * 构造最优值的递归关系表达式: $paths[i][j]=paths[i-1][j]+paths[i][j-1]$
    * 最优值算法描述: 从坐标 $(0,0)$ 开始依次遍历每一个坐标并计算其路径数，需要注意的是由于只能向右和向下移动，导致在上边界和左边界的路径数目受到限制产生边界条件需要单独计算；
    * 构造最优解: 当整个地图的坐标点都被遍历一遍后，到达各坐标点的路径数也确定了，取 $paths[n-1][m-1]$ 即为到达标记处的路径数

## **problem 63: UniquePathsWithObstacles**
> 动态规划，在62题路径问题的基础上引入路障增加难度
* 当前解法: 动态规划算法，定义一个最优解数组paths来记录到达当前坐标$(i,j)$的路径数目，解法基本思路同62题
    * 确定问题具有最优子结构性质: 在这个题目的场景中到达坐标$(i,j)$的路径数可以通过它上和左边的坐标点路径数来确定；
    * 构造最优值的递归关系表达式: $paths[i][j]=(obstacleGrid[i][j]==0)?(paths[i-1][j]+paths[i][j-1]):0$
    * 最优值算法描述: 大体思路和62相似，但是引入了路障map，在计算 $(i,j)$ 的路径数时需要加入是否有路障的判断，该点有路障则到达该点的路径数为0；
    * 构造最优解: 遍历整个map后，paths存储为能到达的每个点的最优路径数，更加实际返回坐标获取最优解；

## **problem 64: MinPathSum**
> 动态规划，在之前求解路径的基础上给每条路径加上了权重，求权重最小的路径
* 当前解法: 动态规划算法，定义dp数组来存储到达当前点 $(i,j)$ 的最小路径和，解法和前两题相同
    * 构造最优值的递归关系表达式: $dp[i][j]=min(dp[i-1][j], dp[i][j-1]) + grid[i][j]$

## **problem70: ClimbStairs**
> 动态规划，之前的场景都是在二维的map，这次换成一维的path，集体思路还是相似
* 当前解法：动态规划算法，定义dp数组存储到达层 $i$ 的方法数，$dp[n-1]$ 即达到顶层的方法数
    * 构造最优值的递归关系表达式：$dp[i]=dp[i-1] + dp[i-2] (i >= 2)$

## **problem32: LongestValidParentheses**
> 动态规划, 不过目前题目的解法没有用到动态规划
* 当前解法: 类似于遍历方法，定义数组dp来存储以$i$起始的有效括号长度，用$(length, end + 1)$表示有效括号长度以及该子串结尾的下一个位置，在没有有效括号的情况下才会依次遍历字符串
    * 确定每一对数的值: 输入子串的$offset: pos$以及对应的$string$: substr，通过设置$checkpoint$来记录当前的组成的括号是否有效；
    * $checkpoint$计算规则: $checkpoint = (char == '(') ? checkpoint + 1 : checkpoint - 1$
    * 有效长度更新规则: 当$checkpoint == 0$时，对有效长度进行更新， 始终存最长的值，由于左括号必须先出现所以当$checkpoint < 0 $时即结束本次括号匹配；
    * 如果以$i$起始找到有效字符串，那么之后的括号匹配以$i+length$起始，否则以$i+1$起始
* 动态规划解法: 